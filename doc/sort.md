# 排序

- [插入排序](#插入排序)
- [交换排序](#交换排序)
- [选择排序](#选择排序)
- [分配排序](#分配排序)
- [归并排序](#归并排序)
- [其他](#其他)

# 插入排序（直接插入排序、希尔排序）@文秀 @紫祥

## 希尔排序
[希尔排序](https://www.cnblogs.com/chengxiao/p/6104371.html)

## 直接插入排序

将一个记录插入到已排好序的序列中，从而得到一个新的有序序列（将序列的第一个数据看成是一个有序的子序列，然后从第二个记录逐个向该有序的子序列进行有序的插入，直至整个序列有序）

![直接插入排序](https://h0.hucdn.com/open201944/9a8f0cd35fa07c04_928x1110.png)

# 交换排序（冒泡排序、快速排序）@新新 @渝苹
![新新贡献](https://h0.hucdn.com/open201944/2e5beef77a927d5c_2220x1376.png)


# 选择排序（直接选择排序、堆排序）@高听

## 堆排序
堆排序是一种原地的、时间复杂度为 O(nlogn) 的排序算法。

#### 什么是堆
- 堆是一个完全二叉树；
- 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值

#### 如何实现一个堆
完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。因为我们不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。

堆化（插入一个数，调整，维持堆的特性）非常简单，就是顺着节点所在的路径，向上或者向下，对比，然后交换。
![image](https://static001.geekbang.org/resource/image/e3/0e/e3744661e038e4ae570316bc862b2c0e.jpg)

#### 如何基于堆实现排序
我们可以把堆排序的过程大致分解成两个大的步骤，建堆和排序。

##### 建堆
首先将数组原地建成一个堆。所谓“原地”就是，不借助另一个数组，就在原数组上操作。
#### 堆排序
调整堆，调整过程需要保证堆序性质：在一个二叉堆中任意父节点大于其子节点。

堆排序，取出位于堆顶的第一个数据（最大堆则为最大数，最小堆则为最小数），放入输出数组B 中，再将剩下的堆作调整堆的迭代/重复运算直至输入数组 A中只剩下最后一个元素。

输出：输出数组B，里面包含的元素都是A 中的但是已经按照要求排好了顺序

#### 评价
评价算法好坏
堆排序是非稳定的排序算法

分类：排序算法

数据结构：数组

最优时间复杂度：O(n*log(n))，当keys 的值都不一样；O(n)，当keys 的值都一样

最坏时间复杂度：O(n*log(n))

平均时间复杂度：O(n*log(n))

最坏空间复杂度：辅助O(1)

### 选择排序
#### 思想
首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的序列进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种

#### 时间复杂度
![image](https://static001.geekbang.org/resource/image/1f/fd/1f6ef7e0a5365d6e9d68f0ccc71755fd.jpg)

### 参考文档
- [堆排序](https://zhuanlan.zhihu.com/p/45725214)
- [选择排序](http://bubkoo.com/2014/01/13/sort-algorithm/selection-sort/)

# 分配排序（箱排序、基数排序）@叶昶

- [分配排序](#分配排序)
    - [箱排序](#箱排序)
    - [基数排序](#基数排序)

## 基本思想
排序过程无须比较关键字，而是通过"分配"和"收集"过程来实现排序.它们的时间复杂度可达到线性阶：O(n)。

## 箱排序

### 桶排序基本思想
假设有一组长度为N的待排关键字序列K[1....n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数 ，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标 i) ，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。然后依次枚举输出B[0]....B[M]中的全部内容即是一个有序序列。

### 算法分析
分配过程的时间是O(n)；收集过程的时间为O(m) （采用链表来存储输入的待排序记录）或O(m+n)。因此，箱排序的时间为O(m+n)。若箱子个数m的数量级为O(n)，则箱排序的时间是线性的，即O(n)。

## 图解
<img src="https://img-blog.csdnimg.cn/20190219081232815.png">


## 基数排序

### 基数排序基本思想
基数排序是对桶排序的改进和推广。如果说桶排序是一维的基于桶的排序，那么基数排序就是多维的基于桶的排序。

将所有待比较数值(正整数)统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。

基数排序分为两种LSD和MSD。
- LSD(Leastsignificant digital)：最低有效位优先，即从右向左开始排序。 
- MSD(Mostsignificant digital)：最高有效位优先，即从左往右开始排序

### 算法分析
- 基数排序的时间是线性的(即O(n))。
- 基数排序所需的辅助存储空间为O(n+rd)。
- 基数排序是稳定的

## 图解
<img src="https://img-blog.csdnimg.cn/20190219112853647.png">

# 归并排序 @秦辉

- [归并排序](#归并排序)
    - [概念](#概念)
    - [二路归并](#二路归并)

## 概念

归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。

常见的归并排序包括二路归并和多路归并，多路归并比较复杂，此次不在这里阐述，在下次的外部排序中详细进行说明：

## 二路归并

二路归并其实很简单，我们可以通过下图来理解二路归并的概念：

![二路归并](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218163120151-452283750.png)

首先，我们将字符串依次二分，直到最后两个元素之间进行对比，然后将拆分的单元组依次排序整合，最后得到排序后的字符串。

可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。

其中，分，既是拆分，拆分到两个元素一一对比，接下来主要说治。

我们需要将两个已经有序的子串合并成一个新的有序串，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子串，合并为最终的[1,2,3,4,5,6,7,8]。

![二路归并治](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218194508761-468169540.png)

因为原先的两个子串已经排好序，只要一一对比两个子串，然后存放在一个临时变量里，就可以获取到最终排序好的子串。

时间复杂度：

每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log2n|。总的平均时间复杂度为O(nlogn)。而且，归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。



# 其他 @永杰 @紫祥

## 计数排序

### 简介
计数排序是一种非比较性质的排序算法，它的复杂度为O(n+k)（其中k是整数的范围），快于任何比较排序算法。是一种牺牲空间换取时间的做法。

### 思想&算法过程
![贴图在此](https://h0.hucdn.com/open201944/6364d660ba848520_1594x932.png)

### 总结
![总结](https://h0.hucdn.com/open201944/5ba616d4f6b8a375_2062x554.png)

## Timsort
TimSort算法是一种起源于归并排序和插入排序的混合排序算法，设计初衷是为了在真实世界中的各种数据中可以有较好的性能。

基本工作过程是：

1.扫描数组，确定其中的单调上升段和严格单调下降段，将严格下降段反转

2.定义最小基本片段长度，短于此的单调片段通过插入排序集中为长于此的段

3.反复归并一些相邻片段，过程中避免归并长度相差很大的片段，直至整个排序完成，所用分段选择策略可以保证O(n log n)时间复杂性。 

可以看到，原则上TimSort是归并排序，但小片段的合并中用了插入排序。
